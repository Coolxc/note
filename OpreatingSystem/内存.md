内存是用于存放数据的硬件。程序执行前需要先放到内存中才能被CPU处理。

<img src="C:\Users\Administrator\Desktop\oooooo\操作系统\图片\image-20200413162829454.png" alt="image-20200413162829454" style="zoom: 80%;" />

![image-20200413163057416](C:\Users\Administrator\Desktop\oooooo\操作系统\图片\image-20200413163057416.png)

<img src="C:\Users\Administrator\Desktop\oooooo\操作系统\图片\image-20200413163641802.png" alt="image-20200413163641802" style="zoom:80%;" />

### 装入的三种方式

#### 绝对装入

在编译时，如果知道程序将放到内存中的哪个位置，编译程序将产生**绝对地址**的目标代码。装入程序按照装入模块中的地址，将程序和数据装入内存。

编译时就要决定模块的装入位置。如果知道装入模块要从地址为100的地方开始存放，那么装入模块的指令直接就会使用绝对地址。如指令一的地址就是180，那么对应的内存中的地址就是180

这种方式太破了，只适合单道程序环境。

#### 静态重定位

又称可重定位装入。编译、链接后的装入模块的地址都是从0开始的，指令中使用的地址、数据存放的地址都是相对于起始地址而言的逻辑地址。可根据内存的当前情况将装入模块装入到适当的位置。装入时对地址进行**重定位**，将逻辑地址变换为物理地址（地址变换是在装入时一次性完成的）



<img src="C:\Users\Administrator\Desktop\oooooo\操作系统\图片\image-20200413165345804.png" alt="image-20200413165345804" style="zoom:80%;" />

静态重定位的特点是在一个作业装入内存时，必须分配其要求的全部内存空间，如果没有足够的内存，就不能装入该作业。作业一旦进入内存后在运行期间就不能移动，也不能再申请内存空间。

#### 动态重定位（现代操作系统）

<img src="C:\Users\Administrator\Desktop\oooooo\操作系统\图片\image-20200413165642222.png" alt="image-20200413165642222" style="zoom:80%;" />

### 内存空间的分配与回收

 

#### 覆盖技术

由于计算机的内存往往不足以装下这么多的进程，所以引入了覆盖技术，用来解决 程序大小超过物理内存总和 的问题

覆盖技术的思想：将程序分为多个段（多个模块）。常用的段常驻内存，不常用的段在需要时调入内存。

内存中分为一个**固定区**和若干个**覆盖区**

需要常驻内存的段放在固定区中，调入后就不再调出（除非运行结束）

不常用的段放在覆盖区，需要用到时再调入内存，用不到时就会调出内存

<img src="C:\Users\Administrator\Desktop\oooooo\操作系统\图片\image-20200413203209568.png" alt="image-20200413203209568" style="zoom:80%;" />

A作为主程序就放到固定区。B和C不可能同时被调用，总得有个先后，所以他们俩可以共用一个覆盖区，覆盖区的大小就为他们俩的最大值，这样都能容得下。DEF也是一样共享一个覆盖区

必须由程序员声明覆盖结构，操作系统完成自动覆盖。

缺点：对用户不透明，增加了用户编程的负担

这种技术已经很少使用了

#### 交换技术

思想：内存空间紧张时，系统将内存中某些进程暂时换出外存，将外存中某些已经具备运行条件的进程换入内存（进程在内存与磁盘之间动态调度）

交换技术也就是进程的中级调度技术，**内存只保存某些进程的PCB**，进程的程序和数据部分被换到外存中。PCB会保存进程在外存中的位置。

进程被保存在外存的**对换区**中：在具有对换功能的操作系统中，通常把磁盘空间分为**对换区和文件区**两部分。文件区一般采用**离散分配**的方式来提高空间利用率，而对换区为了效率则采用**连续分配**的方式。

优先换出阻塞进程，可换出优先级低的进程。为了防止优先级低的进程在被调入内存后又很快被换出，有的系统还会考虑进程在内存的驻留时间，如果一个可怜的低优先级进程在内存驻留的时间太短那么就暂时不会将他换出。

#### 固定分区分配

<img src="C:\Users\Administrator\Desktop\oooooo\操作系统\图片\image-20200413210035840.png" alt="image-20200413210035840" style="zoom:80%;" />

<img src="C:\Users\Administrator\Desktop\oooooo\操作系统\图片\image-20200413210300451.png" alt="image-20200413210300451" style="zoom:80%;" />

#### 动态分区分配

这种分配方式不会预先划分内存分区，而是在进程装入内存时根据进程的大小动态的建立分区，并使分区的大小正好适合进程的需要。因此系统分区的大小和数目是可变的。

**可以使用两种数据结构来记录内存使用情况**

> <img src="C:\Users\Administrator\Desktop\oooooo\操作系统\图片\image-20200413211055422.png" alt="image-20200413211055422" style="zoom:80%;" />

**把一个作业装入内存时，需要按照一定的动态分区分配算法，从空闲分区表（或分区链）中选出一个分区分配给该作业。**

动态分区分配没有内部碎片，但是有外部碎片

内部碎片：分配给某些进程的内存区域中，有些部分没有用上

外部碎片：内存中的某些空闲分区由于太小而难以利用

可以通过紧凑（拼凑，Compaction）技术来解决外部碎片。将进程都拼一块

##### 动态分区分配算法

**首次适应算法：**每次都从低地址开始查找，找到第一个能满足大小的空闲分区

> 原理：空闲分区以地址递增的次序排列。每次分配内存时顺序查找空闲分区链（或分区表），找到大小能满足要求的一个空闲分区。优先使用更小的空闲区间，所以空闲分区按容量递增的次序链接。每次插入新进程就会将链表重新排列以按序递增

**最坏适应算法：**为了解决最佳适应算法的问题（即留下太多难以利用的小碎片），可以在每次分配时优先使用最大的连续空闲区。。。只需将链表按递减次序排列即可。

**邻近适应算法：**如果每次都从上次查找结束的位置开始检索，就能解决上两种算法会产生许多小碎片的问题。

#### 非连续分配管理方式

以上的分配方式都要求进程是不可分割的，非连续分配方式下进程可以被分成多个段存在不同的位置

基本分页存储管理思想：把内存分为一个个大小相等的分区，再按照分区大小把进程拆分成一个个小部分

<img src="C:\Users\Administrator\Desktop\oooooo\操作系统\图片\image-20200414071437356.png" alt="image-20200414071437356" style="zoom:80%;" />

<img src="C:\Users\Administrator\Desktop\oooooo\操作系统\图片\image-20200414081130030.png" alt="image-20200414081130030" style="zoom:80%;" />

<img src="C:\Users\Administrator\Desktop\oooooo\操作系统\图片\image-20200414081422316.png" alt="image-20200414081422316" style="zoom:80%;" />

![image-20200414081447891](C:\Users\Administrator\Desktop\oooooo\操作系统\图片\image-20200414081447891.png)

![image-20200414081535336](C:\Users\Administrator\Desktop\oooooo\操作系统\图片\image-20200414081535336.png)

![image-20200414082046403](C:\Users\Administrator\Desktop\oooooo\操作系统\图片\image-20200414082046403.png)

![image-20200414082341155](C:\Users\Administrator\Desktop\oooooo\操作系统\图片\image-20200414082341155.png)

根据逻辑地址计算出页号，然后去表中查找对应的块号（页框号）就能找到内存中的具体块位置

#### 基本地址变换机构

通常会在系统中设置一个页表寄存器（PTR），存放页表在内存中的起始地址F和页表

长度M。进程未执行时，页表的起始地址和页表长度放在进程控制块（PCB）中，当进程被调度时，操作系统内核会把他们放到页表寄存器中

页面（进程的地址空间）大小一定是2的整数幂。

<img src="C:\Users\Administrator\Desktop\oooooo\操作系统\图片\image-20200414085108780.png" alt="image-20200414085108780" style="zoom:80%;" />

#### 快表

![image-20200414085902066](C:\Users\Administrator\Desktop\oooooo\操作系统\图片\image-20200414085902066.png)

**快表：**又称联想存储器（TLB），是一种访问速度比内存快很多的**高速缓冲存储器**，用来存放当前访问的若干页表项，以加速地址变换的过程。与此对应，内存中的页表常成为慢表。

##### 引入快表后，地址的变换过程

> 1. CPU给出逻辑地址，由某个硬件算出页号、页内偏移量，将页号与快表中的所有页号进行比较
> 2. 如果找到匹配的页号，说明要访问的页表项在快表中有副本，则直接从中取出该页对应的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元。因此，若快表命中，则访问某个逻辑地址仅需**一次访存**即可（因为快表存放于CPU的联想寄存器中，访问时间可以忽略不计，所以这里只计算访问内存的时间）。
> 3. 如果没有找到匹配的页号，则需要访问内存中的页表，找到对应页表项，得到页面存放的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后访问该物理地址对应的内存单元。因此，若快表未命中，则访问某个逻辑地址需要**两次访存**。在找到页表项后，会同时将其存入快表以便后续的访问。但若快表以满则需要按照一定的算法对旧表项进行替换

只要快表命中，就可以节省很多时间。因为局部性原理，一般来说快表的命中率可以达到90%以上。

![image-20200414091944040](C:\Users\Administrator\Desktop\oooooo\操作系统\图片\image-20200414091944040.png)

##### 多级页表

![image-20200414094030029](C:\Users\Administrator\Desktop\oooooo\操作系统\图片\image-20200414094030029.png)

### 分段代替分页

#### 分段

![image-20200414100048851](C:\Users\Administrator\Desktop\oooooo\操作系统\图片\image-20200414100048851.png)

### 段页式管理

![image-20200414101545774](C:\Users\Administrator\Desktop\oooooo\操作系统\图片\image-20200414101545774.png)

![image-20200414101800137](C:\Users\Administrator\Desktop\oooooo\操作系统\图片\image-20200414101800137.png)

![image-20200414101927844](C:\Users\Administrator\Desktop\oooooo\操作系统\图片\image-20200414101927844.png)

![image-20200414102155112](C:\Users\Administrator\Desktop\oooooo\操作系统\图片\image-20200414102155112.png)

## 虚拟内存

传统存储管理方式的特征、缺点

![image-20200414103307106](C:\Users\Administrator\Desktop\oooooo\操作系统\图片\image-20200414103307106.png)

##### 虚拟内存的特征

> 1. 多次性：无需在作业运行时一次性全部装入内存，而是允许被分成多次调入内存
> 2. 对换性：在作业运行时无需一直常驻内存，而是允许在作业运行过程中将作业换入、换出
> 3. 虚拟性：从逻辑上扩充了内存的容量，使用户看到的内存容量远大于实际的容量

#### 请求调页功能

**请求调页存储管理与基本分页存储管理的主要区别**

> 在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行程序
>
> 若内存空间不足，由操作系统负责将内存中暂时不用的信息换出到外存

##### 页表机制

![image-20200414104304134](C:\Users\Administrator\Desktop\oooooo\操作系统\图片\image-20200414104304134.png)

**需要用一种数据结构存储页面的状态。**

**如果之前调入内存中的页面并没有被修改过，那么就不用浪费时间再写回外存了。因为外存保存的副本和现在内存中的一摸一样。**

![image-20200414105006792](C:\Users\Administrator\Desktop\oooooo\操作系统\图片\image-20200414105006792.png)

![image-20200414105315957](C:\Users\Administrator\Desktop\oooooo\操作系统\图片\image-20200414105315957.png)

#### 页面置换算法

##### 最佳置换算法（OPT）

每次选择淘汰的页面将是以后用不使用，或者在最长时间内（相对于其他页面）不再被访问的页面。这样可以保证最低的缺页率

##### 先进先出置换算法（FIFO）

最先进入内存的页面将最早被置换到外存

##### 最近最久未使用置换算法（LRU，least recently used）

每次淘汰的页面是最近最久未使用的页面

原理：赋予每个页面对应的页表项中，用访问字段记录该页面自上次被访问以来所经历的时间t。当需要淘汰一个页面时，选择现有页面中t值最大的，即最近最久未使用的页面。

![image-20200414111205691](C:\Users\Administrator\Desktop\oooooo\操作系统\图片\image-20200414111205691.png)

此时3号页面需要进入内存，那么就需要从内存中置换出去一个页面。从3号页面向前逆向查看 8 - 1 - 2 - 7，这时所有页面都有了，并且7号是知道3号页面进来时最久没使用的，所以淘汰7号。

![image-20200414111451387](C:\Users\Administrator\Desktop\oooooo\操作系统\图片\image-20200414111451387.png)

此时7号页要进入内存，向前看，最后出现的是8号。向前看最后出现的就是最早被使用的，所以淘汰8号

**缺点：实现困难，开销大**

##### 时钟置换算法（CLOCK）

时钟置换算法是一种性能和开销较为均衡的算法，又称为CLOCK算法，或最近未使用算法（NRU，Not Recently Used）

**简单的CLOCK算法实现：**为每个页面设置一个访问位，再将内存中的页面都通过链接指针连接成一个循环队列。当某页被访问时，其访问位置为1.当需要淘汰一个页面时，只需要检查页的访问位。如果是0，就选择将该页换出；如果是1则将他置为0，并且暂不换出，继续检查下一个页面。若第一轮扫描中所有页面都是1，则将这些页面的访问位依次置为0后再进行第二轮扫描（第二轮扫描中一定会有访问页为0的页面，因此简单的CLOCK算法选择一个淘汰页面最多会进行两轮的扫描）

**例：**

> 有页面访问串：1，3，4，2，5，6，3，4，7。为这个进程分配的内存块数为5
>
> 当访问到6时已经没有内存块可用了，并且此时队列中的访问位都为1 。 根据算法会将所有页面的访问位置0 。 此时就会淘汰1号页面并且6号页面的访问位置1。
>
> 然后访问3，4号页面，因为他们俩都在内存中，所以只是将他们的访问位置1
>
> 然后访问7号页面，这时需要置换。扫描队列，碰到访问位为1的页面就跳过并将访问位置0 。 知道扫描到2号页面发现他的访问好为0，就将2号淘汰。7号进入队列并将访问号置1 。

#### 改进型的时钟置换算法

简单的时钟置换算法仅考虑到一个页面最近是否被访问过。事实上，如果被淘汰的页面没有被修改过就不需要执行IO操作写回外存。只有被淘汰的页面被修改过时才需要写回外存。

**如果页面没有被修改过就不需要再浪费时间写回外存了（外存中保存的副本与这时内存中是一摸一样的），如果页面被修改过就需要将外存中的旧数据覆盖这时就必须需要IO操作了。**

因此除了考虑一个页面最近有没有被访问过之外，操作系统还应该考虑页面有没有被修改过。在其他条件都相同时，应优先淘汰没有修改过的页面，避免IO操作。这就是改进型的时钟置换算法的思想。

![image-20200414140126721](C:\Users\Administrator\Desktop\oooooo\操作系统\图片\image-20200414140126721.png)

![image-20200414140258903](C:\Users\Administrator\Desktop\oooooo\操作系统\图片\image-20200414140258903.png)

## 页面分配与置换策略

![image-20200414141602447](C:\Users\Administrator\Desktop\oooooo\操作系统\图片\image-20200414141602447.png)

![image-20200414141855493](C:\Users\Administrator\Desktop\oooooo\操作系统\图片\image-20200414141855493.png)

##### 何时调入页面

![image-20200414142050217](C:\Users\Administrator\Desktop\oooooo\操作系统\图片\image-20200414142050217.png)

##### 从何处调入页面

![image-20200414142307048](C:\Users\Administrator\Desktop\oooooo\操作系统\图片\image-20200414142307048.png)

![image-20200414142425351](C:\Users\Administrator\Desktop\oooooo\操作系统\图片\image-20200414142425351.png)

![image-20200414142603637](C:\Users\Administrator\Desktop\oooooo\操作系统\图片\image-20200414142603637.png)