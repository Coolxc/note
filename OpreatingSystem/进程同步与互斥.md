## 进程同步

同步也称**直接制约关系**，它是指未完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调他们的**工作次序**而产生的制约关系。进程间的直接制约关系就是他们之间的相互合作

## 进程互斥

把一个和时间段内只允许一个进程使用的资源成为临界资源。许多物理设备（如摄像头、打印机）都属于临界资源。此外还有许多变量、数据、内存你缓冲区等都属于临界资源

对临界资源的访问，必须互斥的进行。互斥也成为间接制约关系。进程互斥指当一个进程访问某临界资源时，另一个想要访问该临界资源的进程必须等待。当前访问临界资源的进程访问结束，释放该资源后另一个进程才能去访问临界资源。

**为了保证系统的整体性能，对临界资源的互斥访问应该遵循以下原则**

> 1. 空闲让进：临界区空闲时，可以允许一个 请求进入临界区的进程立即进入临界区
> 2. 忙则等待：当已有进程进入临界区时，其他试图进入临界区的进程必须等待
> 3. 有限等待：对请求访问的进程，应保证能在有限时间内进入临界区（不会导致饥饿）
> 4. 让权等待：当进程不能进入临界区时，应立即释放处理机，防止进程忙等。占着处理机不干事傻等

#### 进程互斥的软件实现方法

##### 单标志法

算法思想：每个进程在访问完临界区后会把临界区的使用权交给另一个进程。也是就是说每个进程进入临界区的权限只能被另一进程赋予

```c++
int turn = 0; //turn的值表示允许当前进入临界区的进程号
//0号进程
while(turn != 0); //turn=0,跳过while循环直接进入临界区
critical section; //临界区
turn = 1;  //访问玩临界区后将turn置1让1号进程访问
remainder section; //剩余区

//1号进程
while(turn != 1); //除非0号进程主动置turn=1，否则一直循环
critical section; //临界区
turn = 0; //访问完临界区，让给1号进程处理机
remainder section; //剩余区
```

该算法可以实现进程互斥，但是访问临界区的访问权只能由进程主动释放。0号进程可能一直不访问临界区。此时虽然临界区是空闲的，但是1号进程一直无法进入临界区。**所以该算法违背了 空闲让进  原则**

##### 双标志先检查法

算法思想：设置一个布尔型数组flag[]，数组中各个元素用来标记各进程想进入临界区的意愿，比如 `flag[0]=true`意味着0号进程P0想要进入临界区。每个进程在进入临界区之前先检查当前有没有别的进程想要进入临界区，如果没有则把自身对应的标志flag[i]设为true，之后开始访问临界区

```c++
bool flag[2]; //表示进入临界区意愿的数组
flag[0] = false;
flag[1] = false;  //刚开始设置为两个进程都不想进入临界区

//P0进程
while(flag[1]); //判断P1进程是否想要进入临界区，如果flag[1]为true则循环等待
flag[0] = true;  //标记P0进程想要进入临界区
critical section;  //访问临界区
flag[0] = false; //访问完临界区
remainder section; //剩余区

//P1进程
while(flag[0]); //判断P0进程是否想要进入临界区，如果flag[0]为true则循环等待
flag[0] = true;  //标记P1进程想要进入临界区
critical section;  //访问临界区
flag[0] = false; //访问完临界区
remainder section; //剩余区
```

但是如果P0进程和P1进程刚开始同时判断while循环，此时都是false所以都向下执行，那么下一条语句都是将自己的flag置为1，此时P0和P1将会同时访问临界区

**所以双标志先检查法违反了  忙则等待  的原则**

##### 双标志后检查法

对于先检查法，因为是先检查后上锁，最主要的是这两个操作无法一气呵成的执行。所以会导致多个进程同时访问临界区的问题。

**所以引出了后检查法，也就是先上锁，后检查**

先标记自己的标志位为true然后再while循环

但是如果两个进程同时标记自己为true，那么下面的while循环这两个进程都会等待对方设为flase，此时就会互相等待。会产生**饥饿**现象

##### Peterson算法

对于双标志后检查法，如果两个进程都标记自己想要进入临界区那么就会产生谁也不让谁然后谁也进不去的窘境。所以Gary L.Peterson想到了一种方法，如果双方都尝试想要进入临界区，那么就采用**孔融让梨**的方法，主动让对方进入临界区

```c++
bool flag[2]; //表示进入临界区意愿的数组，初始值都是flase
int turn = 0;  //turn 表示优先让哪个进程进入临界区

//P0进程
flag[0] = true;  //表示自己想要进入临界区
turn = 1;  //优先让1号进程进入临界区
while(flag[1] && turn==1); //对方想进，且最后一次是自己让梨，那自己就循环等待
critical section;
flag[0] = false;  //访问完临界区，表示自己已经不想访问临界区了
remainder section;

//P1进程
flag[0] = true;  //表示自己想要进入临界区
turn = 0;  //优先让0号进程进入临界区
while(flag[0] && turn==0); //对方想进，且最后一次是自己让梨，那自己就循环等待
critical section;
flag[1] = false;  //访问完临界区，表示自己已经不想访问临界区了
remainder section;
```

通过设置turn就完美解决了互相等待的窘境。

如果开始P0置flag为true并且turn置1表示优先让P1进入，此时P1也执行这两步。

此时P0到while循环，将不会等待，因为此时的turn被P1置为了0 。

**因为一个进程让出了资源后还会一直while循环等待机会，所以Peterson算法依然没有遵循让权等待的原则**

该算法是软件解决临界区资源最好的算法，但是依然不够完善

#### 进程互斥的硬件实现方法

##### 中断屏蔽方法

利用**开/关中断指令**实现（与原语的思想相同，即在某进程开始访问临界区到结束访问为止都不允许被中断，也就不能发生进程切换，因此也不可能发生两个同时访问临界区的情况）

**优点：**简单、高效

**缺点：**不适用于多处理机，只适用于操作系统内核进程，不适用于用户进程（因为开/关中断指令只能运行在内核态，这组指令如果能让用户随意使用会很危险）

##### TestAndSet指令

简称TS指令，也称TestAndSetLock指令，或TSL指令

TSL指令使用硬件实现的，执行过程不允许被中断，只能一气呵成。

TS逻辑

```c
//布尔型共享变量 lock 表示当前临界区是否被加锁
//true 表示已加锁， false表示未加锁
bool TestAndSet (bool *lock){
    bool old;
    old = *lock; //old用来存放lock原来的值
    *lock = true; //无论之前是否已加锁，都将lock设为true
    return old; //返回lock原来的值
}

//以下是使用TSL指令实现互斥的算法逻辑
while (TestAndSet (&lock)); //上锁并检查
//临界区代码段.........
lock = false;
//剩余区代码段.........
```

若lock刚开始是flase那么TSL返回的值为false，跳过while循环向下执行。注意到此时的TSL返回的是旧lock值，此时的lock已经改为了true也就是我跳过while了并且给我自动加锁了，访问玩临界区资源后将释放锁。

若lock刚开始为true则一直循环等待，等待其他进程释放锁

**一边进行检查锁一边进行上锁，上锁后只需返回旧的值即可，妙妙秒**

但是该方法不满足 让权等待 的原则。。。在那时无法进入临界区的进程会一直占用CPU循环的查询锁从而导致忙等。。。。

##### Swap指令

也叫Exchange指令，或简称XCHG指令

Swap指令是用硬件实现的，执行的过程不允许被中断，只能一气呵成。以下用C语言来描述Swap指令的逻辑

```c
//Swap的作用是交换两个变量的值
Swap (bool *a, bool *b){
    bool temp;
    temp = *a;
    *a = *b;
    *b = temp;
}

//以下是用Swap指令实现互斥的算法逻辑
//lock表示当前临界区是否被加锁
bool old = true;
while (old == true){ //如果lock为flase那么交换后的old为false那么跳出循环
	Swap (&lock, &old);
}
//临界区代码段........
lock = false;
//剩余区代码段
```

优点与缺点都和TSL的一样。。。

### 信号量机制

用户进程可以通过使用操作系统提供的一对原语来对信号量进行操作，从而很方便的实现了进程互斥、进程同步

信号量其实就是一个变量（可以是一个整数，也可以是更复杂的记录型变量），可以用一个信号量来表示系统中某种资源的数量。比如：系统中只有一台打印机，就可以设置一个初始值为1的信号量

原语：由关中断和开中断指令实现，无法被打断，一气呵成

**一对原语：**`wait(s)`和`signal(s)`，可以把原语理解为我们自己写的函数，函数名分别为wait和signal，其中的s就是我们出传入的信号量参数

wait、signal原语通常简称为P、V操作（来自荷兰语proberen(尝试)和verhogen(增加)）。因此经常称为`P(s)`和`V(s)`

#### 整型信号量

用一个整形的变量，用来表示系统中某种资源的数量

```c
ins s = 1; //初始化信号量，表示系统中可用的打印机数量
void wait(int s){  //P操作
    while (s <= 0);  //如果资源不足则一直循环等待
    s = s - 1;  //如果资源足够则占用一个资源
}

void signal (int s){ //V操作
    s = s + 1;  //使用完资源后，释放资源
}

//进程P0
wait(s); //申请资源
//使用打印机资源
signal(s); //释放资源
```

wait函数体的操作类似于双标志先检查法，先检查后上锁

但是还是会发生忙等

#### 记录型信号量（重要）

为了解决整形信号量存在的忙等问题，引出了记录型的信号量。用一个数据结构存储

```c
//记录型信号量的定义
typedef struct {
    int value;  //剩余资源数
    struct process *L;  //等待资源的进程队列
}semaphore;

//wait，，P操作
void wait (semaphore s){
    s.value--;  //占用资源
    if (s.value < 0){  //如果没有资源了就阻塞自己并将自己挂到等待队列
        block (s.L);
    }
}

//signal，V操作
void signal (semaphore s){
    s.value++;  //释放资源
    if (s.value <= 0){ //如果有别的进程在等待该资源则唤醒。每个想要使用改资源的进程都会执行wait来无阻碍的使s.value--，所以若还有进程等待这个value肯定为负数
        wakeUp(s.L);
    }
}
```

因为进程申请不到资源就会自己阻塞自己并放到阻塞队列，所以不会出现忙等

#### 信号量机制实现进程互斥

```c
semaphore mutex = 1; //初始化信号量，为1时可以实现互斥机制

P1(){
    ....;
    P(mutex);  //申请资源
    //临界区代码段.........
    V(mutex);  //释放资源
}

P2(){
    ....;
    P(mutex);  //申请资源
    //临界区代码段.........
    V(mutex);  //释放资源
}
```

#### 信号量机制实现进程同步

同步指的是要让进程按照要求的先后顺序执行，有可能P3要依赖P1的计算结果所以必须要在P3之前执行P1

**步骤：**

> 1. 设置同步信号量S，初始值为0
> 2. 在想要先前操作的代码后执行 V(S)；也就是只有我执行完才会释放资源
> 3. 在想要之后操作的代码之前执行 P(S)；也就是只有申请到资源才会向下执行

```c
//如：我们想要代码2一定要在代码4之前执行
semaphore S = 0;  //初始化同步信号量

P1(){
    代码1;
    代码2;
    V(S);  //释放资源，如果阻塞队列有阻塞进程则唤醒
    代码3;
}

P2(){
    P(S);  //申请资源，如果没有资源则被放入到阻塞队列等待被唤醒
    代码4;
    代码5;
    代码6;
}

//此时的信号量为0
//若先执行到V(S)操作，那么S会加1.之后执行到P2的P(S)操作时由于S=1表示有可用资源，P(S)操作会执行S--，这时S的值变为0，此时P(S)操作是不会执行bvlock原语的，因为刚才的V(S)释放了资源，向下继续执行代码4.自此实现了前后关系

//若先执行到P(S)操作，注意到此时的S=0，那么P(S)操作中的S--就会将S变为负数那么改进程就被放到阻塞队列等待被唤醒。  这时执行到P1的V(S)时就会释放资源并唤醒阻塞队列中的一个进程。 

//不管怎样，代码2总是在代码4之前执行
```

<img src=".\图片\image-20200413105629723.png" alt="image-20200413105629723" style="zoom:80%;" />

妙 妙 妙

#### 读写问题

多个写进程需要互斥的写，多个读可以同时读。为了保证数据完整性读和写也要互斥。

```c
semephore rw = 1;  //读写的互斥访问
int count = 0;  //记录当前有多少读在进行，只有第一个读需要P(W)和最后一次读需要V(W)，这样保证了可以多个读
semaphore mutex = 1; //用于保证count变量的互斥访问
semaphore w = 1;  //用于实现 "写优先"，第一个读进程读完就会释放w，写相对的优先了

whiter(){
    while(1){
        P(w);  //获取w
        P(rw);  //获取读写权限
        写文件...;
        V(rw);
        V(w);
    }
}

reader(){
    while(1){
        P(w); //获取w
        P(mutex); //读进程互斥信号量
        if(count == 0){ //如果还没有读进程那么获取rw，阻塞写进程
            P(rw);
        }
        count++; //否则直接count++
        V(mutex); //释放互斥锁，保证这一段同一时间只有一个读执行
        V(w);  //释放w
        读文件....;
        P(mutex); //保证这一段同一时间只有一个读进程执行
        count--;
        if(count == 0){
            V(rw);
        }
        V(mutex);
    }
}
```

通过设置count变量达到了可以让多个读进程共同读取数据，读文件这一段是可以同时进行的，但是在执行：获取和释放rw和count++--时读进程是需要互斥的进行的。否则如果同时进入到`if(count == 0)`此时判断都为true那么多个读就会有多个`P(rw)`。

这里通过设置`w`信号量使得写进程不会产生饥饿现象，每一个读进程`P1`进来后执行到 `V(w)`这里会释放`w`。所以写进程可以执行`P(w)`，此时写进程被阻塞在了`P(rw)`。然后如果新来了一个读进程P2，那么它就会被卡在 `P(w)`这一行，等待P1读完文件然后释放rw后写进程就能继续执行了，写进程执行完就会执行 `V(w)`释放w，此时P2就可以继续向下。

如果不设置w信号量，那么新的读进程如果可以源源不断的达到，那么写进程可能会出现饥饿现象。因为此时read的count变量永远不会达到0 。有了w就能让写进程掌握主动权牵制新的读进程。

## 管程

1973年，Brinch Hansen首次在程序设计语言 Pascal 中引入了管程，这是一种高级语言同步机制

Java中，如果使用关键字synchronized来描述一个函数，那么这个函数在同一时间段内只能被一个线程调用

## 死锁

在并发环境下，各进程竞争资源而造成的一种互相等待对方手里的资源，导致各进程都阻塞，都无法向前推进的现象，就是死锁。发生死锁后若无外力干涉这些进程都将死等下去

##### 死锁发生的条件

> **互斥：**只有对必须互斥使用的资源的争抢才会导致死锁。对于不用阻塞等待的资源如内存、扬声器是不会发生死锁的
>
> **不剥夺条件：**进程所获得的资源在未使用完之前，不能由其他进程强行剥夺处理机，只能主动释放
>
> **请求和保持条件：**进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放
>
> **循环等待条件：**存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求

#### 死锁的处理策略

##### 预防死锁

破坏死锁产生的四个必要条件中的一个或几个

> **破坏互斥条件**
>
> > 将只能互斥使用的资源改造为允许共享使用。比如SPOOLing技术。操作系统可以采用SPOOLing技术把独占设备在逻辑上改造成共享设备。比如：使用了SPOOLing技术后，在各进程看来，自己对打印机资源的使用请求立即就被接收处理了，不需要再阻塞等待。其实是放在了一个队列中。
> >
> > 但有时候必须要保持互斥性，并且有些资源无法改造。因此很多时候都无法破坏互斥条件
>
> **破坏不可被剥夺条件**
>
> > 方案一：当某个进程请求新的资源得不到满足时将会放弃拥有的所有资源。供其他进程使用
> >
> > 方案二：当某个进程请求的资源被占有时，可由操作系统协助将想要的资源强行剥夺。这种方式一般需要考虑各进程的优先级。
> >
> > 缺点：实现复杂。并且释放已经获得资源那么就可能导致之前完成的工作失效需要重新做。
>
> **破坏请求和保持条件**
>
> > 可以采用静态分配方法，即进程在运行前一次申请完它所需要的所有资源，在它的资源未满足前不让它投入运行。一旦投入运行，这些资源就一直归它所有，改进程就不会再取请求其他任何资源。
> >
> > 缺点：资源利用率极低
>
> **破坏循环等待条件**
>
> > 可以采用顺序资源分配法。首先给系统中的资源编号，规定每个进程必须按编号递增的是顺序请求资源，同类资源（即编号相同的资源）一次性申请完
> >
> > 原理：一个进程已占有小编号的资源时才有资格申请更大编号的资源。已持有大编号资源的进程不能逆向申请小编号的资源，从而不会产生循环等待的现象。
> >
> > 缺点：不方便新增设备，可能需要重新编号

##### 避免死锁

用某种方法防止系统进入不安全的状态，从而避免死锁（银行家算法）

> 安全序列：如果系统按照这种序列分配资源则每个进程都能顺利完成。只要找到一个安全序列则系统就是**安全状态**，安全序列可能有多个
>
> 如果分配资源之后，系统中找不到任何一个安全序列，系统就进入了**不安全的状态**。这就意味着之后可能所有进程都无法顺利执行下去。当然，如果有进程提前归还了一些资源那么系统还是有可能重新回到安全状态的，不过在分配资源之前我们总是要考虑到最坏的情况。
>
> 如果系统处于安全状态那么一定不会发生死锁。如果系统进入不安全状态就有可能发生死锁。但是。。如果发生了死锁那么一定是处于不安全状态
>
> **银行家算法**
>
> > 银行家算法是荷兰学者Dijkstra为银行系统设计的，以确保在发放现金贷款时不会发生不能满足所有客户需要的情况，后来该算法被用于操作系统中用于避免死锁。
> >
> > **核心思想：**在进程提出资源申请时，先预判此次分配是否会导致系统进入不安全的状态。如果会进入那么暂时不答应这次请求，让改进程先阻塞等待
> >
> > 太难了- -

##### 死锁的检测和解除：

允许死锁的发生，不过操作系统会负责检测出死锁的发生，然后采取某种措施接触死锁

> 死锁检测：
>
> 太难了- -