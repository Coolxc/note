## 进程

程序：就是一个指令序列

一个进程的程序段和它操作的数据段存放在内存中不同的位置，多个程序共存在内存中

**PCB：**操作系统会为每个系统配置一个数据结构，称为进程控制块（PCB），用来描述进程的各种信息（如该进程的程序代码在内存中的存放位置）

**程序段、数据段、PCB**三部分组成了进程实体（进程映像）。一般情况下，我们把进程实体简称为进程。例如所谓的创建进程实质上就是创建进程实体中的PCB；而撤销进程实质上是撤销进程实体中的PCB。

**PCB是进程存在的唯一标志**

#### 进程的一般定义

> 1. 进程是程序的一次执行过程。也就是创建PCB与撤销PCB的一次过程
> 2. 进程是一个程序及其数据在处理机上顺序执行时所发生的活动
> 3. 进程是具有独立功能的程序在数据集合上运行的过程，他是系统进行资源分配和调度的一个独立单位

<img src=".\图片\image-20200412111551899.png" alt="image-20200412111551899" style="zoom:80%;" />

#### PCB内容

**进程描述信息**

> 进程标识符PID：当进程被创建时，操作系统会为该进程分配唯一的ID
>
> 用户标识符UID：标识该进程所属用户

**进程控制和管理信息**

> 进程当前状态
>
> 进程优先级

**资源分配清单**

> 程序段指针
>
> 数据段指针
>
> 键盘
>
> 鼠标

**处理机相关信息**

> 各种寄存器的值：当进程切换时就需要记录当前进程信息。如记录程序计数器的值

#### 进程的组织与管理

在一个系统中可能存在数百个PCB。需要对他们进行高效的组织管理

##### 进程的组织方式

> **链接方式**
>
> > 按照进程状态将PCB分为多个队列，注意队列中的是PCB
> >
> > 操作系统持有指向各个队列的指针
> >
> > > 执行指针：指向当前处于运行态的进程，单个CPU同一时刻只能有一个进程会处于运行态
> > >
> > > 就绪队列指针：指向当前处于就绪态的进程队列 [PCB1, PCB3....]。通常会将优先级最高的放在队头
> > >
> > > 阻塞队列指针：指向当前处于阻塞态的进程队列。另外根据阻塞原因不同还会再分为多个阻塞队列
>
> **索引方式**
>
> > 根据进程状态的不同，建立几张索引表
> >
> > 操作系统持有指向各个索引表的指针
> >
> > <img src=".\图片\image-20200412112819317.png" alt="image-20200412112819317" style="zoom:80%;" />

##### 进程的五种基本状态

**运行态：**占有CPU，并在CPU上运行。如果是单核CPU那么同时只能有一个进程处于运行态

**就绪态：**已经具备运行条件，但由于没有空闲CPU，而暂时不能运行。如已经获取打印机资源，就等着用CPU了

**阻塞态：**因等待某一事件而暂时不能运行。为了充分利用CPU，需要将该进程运行所需要的资源都获取完毕了才能有资格抢占CPU。

**创建态：**进程正在被创建，操作系统为其分配资源，初始化PCB

**终止态：**进程正在从系统中撤销，操作系统会回收进程拥有的资源，撤销PCB

<img src=".\图片\image-20200412144617888.png" alt="image-20200412144617888" style="zoom:80%;" />

##### 进程控制

进程控制就是实现进程各个状态之间的转换

修改进程的状态通过修改PCB的内容来实现

修改完状态后将该进程的PCB插入到合适的队列中，如就阻塞态到就绪态的队列中

使用原语来修改进程状态，原语的特点是执行期间不允许中断，只能一气呵成。这种不可被中断的操作成为原子操作。原语采用 关中断 和 开中断 来实现，只能运行在内核态

过程：关中断 =》 原语代码..... =》 开中断。关中断后外部的中断信号将无效

**进程转换的原语所要做的就是下面这三件事情**

> 1. 更新PCB中的信息（如修改进程状态标志、将运行环境保存到PCB、从PCB恢复运行环境）
>
> > 所有的进程控制原语一定都会修改进程状态标志
> >
> > 剥夺当前运行进程的CPU使用权必然需要保存其运行环境
> >
> > 某进程开始运行前必然要恢复其运行环境
>
> 2. 将PCB插入合适的队列
> 3. 分配/回收资源

#### 进程通信

进程是分配系统资源的单位，各个进程所拥有的内存空间都是相互独立的。所以两个不同的进程无法互相访问对方的内存空间。

##### 共享存储

内存中有一块共享空间，各个进程都可以访问该空间

两个进程对共享空间的访问必须是互斥的，互斥通过工具来实现，如PV操作。

**共享存储分为两种**

> 基于数据结构的共享
>
> > 如共享空间里只能存放一个固定长度的数组，这种共享方式速度慢，限制多，是一种低级共享方式
>
> 基于存储区的共享
>
> > 在内存中划出一块共享存储区，数据的形式、存放位置都由进程控制而不是操作系统。相比之下这种共享方式速度更快，是一种高级通信方式。

##### 管道通信

**管道：**指用于连续读写进程的一个共享文件，又名pipe文件。其实就是在内存中开辟一个固定大小的缓冲区

> 1. 管道只能进行半双工通信，某一个时间段内只能实现单向的传输。如果要实现双向同时通信，则需要设置两个管道
>
> 2. 各个进程要互斥的访问管道 
> 3. 数据已字节流的形式写入管道，当管道写满时，写进程的write()系统调用将被阻塞，等待进程将数据取走。当读进程将数据全全全都取走后，，管道变空，此时读进程的read()系统调用将被阻塞
> 4. 如果写没满就不允许读。如果没读空就不允许写
> 5. 数据一旦被读出，就从管道中被抛弃，这就意味着读进程最多只能有一个，否则可能会有读错数据的情况

##### 消息传递

进程间的的数据交换以格式化的消息为单位。进程通过操作系统提供的 发送消息/接受消息 两个原语进行数据交换

<img src=".\图片\image-20200412152512440.png" alt="image-20200412152512440" style="zoom:80%;" />

## 线程

内核实现里，thread只是“有相同process ID和不同thread ID的process”，内核在进行调度的时候都当你是进程。

一个QQ进程内可以同时聊天和发送文件。这里线程成为了程序执行的最小单位

引入线程后，不仅是进程之间可以并发，进程内的各线程之间也可以并发，从而进一步提升了系统的并发速度，使得一个进程内也可以并发处理各个任务

引入线程后，进程只是作为除CPU之外的系统资源的分配单元（如打印机、内存等都是分配给进程的，一个进程内的所有线程共享这些资源）。

#### 线程的属性

> 线程是处理机调度的基本单位，线程占用CPU而不是进程。进程只管索要资源
>
> 多核CPU中，各个线程可以占用不同的CPU
>
> 每个线程都有一个线程ID和线程控制块TCB
>
> 线程也有就绪、阻塞、运行三种状态
>
> 线程几乎不拥有系统资源
>
> 同一进程的不同线程间共享进程的资源
>
> 由于共享内存地址空间，同一进程中的线程间通信无需操作系统干预
>
> 同一进程中的线程切换不会引起进程切换；不同进程中的线程切换会引起进程切换
>
> 切换同进程内的线程，系统开销很小
>
> 切换进程，系统开销较大

#### 线程的实现方式

##### 用户级线程（User-Level Thread, ULT）

用户级线程由应用程序通过**线程库**实现。所有的线程管理工作都由**应用程序**负责（包括线程的切换）

用户级线程中，线程切换可以在**用户态**下即可完成，无需操作系统的干预

在用户看来，是有多个线程。。但在操作系统内核看来，并意识不到线程的存在。（用户级线程用户能看到，但对操作系统透明）

所以，用户级线程就是只能从用户的视角看到的线程

用户级线程不需要频繁的由用户态切换到核心态，所以系统开销要小。也不需要完全依赖于内核的作业调度，相对更可控。

##### 内核级线程（Kernel-Level Thread, KLT）

内核级线程的管理工作由**操作系统**完成。

线程调度、切换等工作都由内核负责，因此内核级线程的切换必须要在**内核态**下完成

<img src=".\图片\image-20200412154458140.png" alt="image-20200412154458140" style="zoom:80%;" />

**重点：：：由于操作系统只看得见内核级线程，所以内核级线程才是处理机分配的单位。所以就算是三核处理器，上图中用户看来是三个线程，但是实际上由于只映射到两个内核级线程所以最多只能用到两个核心**

##### 多线程模型

由用户级线程映射到多少个内核级线程可以引出多线程模型

**多对一模型：**

> 多个用户级线程映射到一个内核级线程
>
> <img src=".\图片\image-20200412155345170.png" alt="image-20200412155345170" style="zoom:80%;" />
>
> 优点：由于用户级线程的切换是由程序完成的不需要切换到核心态，所以线程管理的系统开销小，效率高
>
> 缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可以在多核处理及上并行运行

**一对一模型：**

> 一个用户级线程映射一个内核级线程
>
> <img src=".\图片\image-20200412155406728.png" alt="image-20200412155406728" style="zoom: 80%;" />
>
> 优点：当一个线程被阻塞后，别的线程还可以继续执行。并发能力强。多线程可以在多核处理机上并行执行
>
> 缺点：一个用户进程会占用多个内核级线程，线程的切换必须有操作系统完成，所以需要切换到内核态。因此线程管理的成本高，开销大

**多对多模型：**

> <img src=".\图片\image-20200412155644226.png" alt="image-20200412155644226" style="zoom:80%;" />
>
> 克服了多对一模型并发度不高的缺点，又克服了一对一模型一个用户进行占用太多内核级线程，开销太大的缺点

