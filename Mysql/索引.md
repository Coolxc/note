索引：索引是帮助MySQL高效查找数据的数据结构。索引是一种排好序的数据结构

索引本身也很大，不可能全部在内存中，因此索引往往以文件的形式存储在磁盘上

##### 索引的缺点

> 实际上索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录，所以索引列也是要占用空间的
>
> 对表进行insert、delete、update时需要更新表，同时也需要更新索引，所以这些操作会慢一些
>
> 索引只是提高效率的一个因素，如果你的MySQL有大量的表，就需要花时间研究建立最优秀的索引，或优化查询

##### 索引分类

> 单值索引
>
> > 一个索引只包含单个列，一个表可以有多个单列索引
>
> 唯一索引
>
> > 索引列的值必须唯一，但允许有值
>
> 复合索引
>
> > 一个索引包含多个列

##### 索引基本语法

> > 创建
> >
> > > `create [unique] index indexName on tableName(columnName(length));`
> > >
> > > `alter tableName add [unique] index indexName on tableName(columnName(length));`
> >
> > 删除
> >
> > > `drop index [indexName] on tableName`
> >
> > 查看
> >
> > > `show index from tableName`

**哪些情况不需要索引**

> 表记录太少
>
> 经常增删改的表
>
> 数据重复且分布平均的表字段，如性别字段就算建了索引也没什么用

## Explain

使用Explian关键字可以模拟优化器执行SQL查询语句，从而知道MySQL是如何处理你的SQL语句的。分析你的查询语句或是表结构的性能瓶颈

**Explain可以得出**

> 表的读取顺序
>
> 数据读取操作的操作类型
>
> 哪些索引可以使用
>
> 哪些索引被实际使用
>
> 表之间的的引用
>
> 每张表有多少行被优化器查询

```mysql
mysql> explain select * from open_user;
+----+-------------+-----------+------------+------+---------------+------+---------+------+------+----------+-------+
| id | select_type | table     | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra |
+----+-------------+-----------+------------+------+---------------+------+---------+------+------+----------+-------+
|  1 | SIMPLE      | open_user | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    1 |   100.00 | NULL  |
+----+-------------+-----------+------------+------+---------------+------+---------+------+------+----------+-------+
```

**id**

> select查询的序列号，包含一组数字，表示查询中执行seleect字句或操作表的顺序
>
> 三种情况
>
> > id相同，执行顺序由上至下
> >
> > id不同，如果是子查询，id序号会递增，id值越大优先级越高，越先被执行
> >
> > id有相同有不同，优先级越高越先执行，相同的顺序执行

**select_type**

> SIMPLE：简单的select查询，查询中不包含子查询或UNION
>
> PRIMARY：查询中包含有复杂的子部分，最外层被标记为PRIMARY
>
> SUBQUERY：在select或where列表中包含了子查询
>
> DERIVED：在from列表中包含的子查询被标记为DERIVED (衍生)，MYSQL会递归执行这些子查询，把结果放在临时表里
>
> UNION：若第二个SELECT出现在UNION之后，则被标记为UNION，若UNION包含在from子句的子查询中，外层select将被标记为DERIVED
>
> UNION RESULT：从UNION表获取结果的select

**table：**显示这一行的数据是关于哪张表的

**type：**显示查询使用了何种类型，从最好到最差依次是：`system>const>eq_ref>range>index>ALL`

**possible_keys：**显示可能应用在这张表中的索引，一个或多个。查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询实际使用

**key：**实际使用的索引。如果为NULL，则没有使用索引

**key_len：**表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。在不损失精确性的情况下，长度越短越好。key_len显示的值为索引字段的最大可能长度，并非实际使用长度，即key_len是根据表定义计算而得，不是通过表内检索得出的

**ref：**显示索引的哪一列被使用了。如果可能的话是一个常数。哪些列或常量被用于查找索引列上的值。

**rows：**根据表统计信息及索引选用情况，大致估算出找到所需的记录所需要读取的行数

**Extra：**

> Using filesort：说明mysql会对数据使用一个外部的索引排序，而不是按照表内二点索引进行排序
>
> Using temporary：使用了临时表保存中间结果，MYSQL在对查询结果排序时使用临时表。常见于排序order by和分组查春group by
>
> USING index：